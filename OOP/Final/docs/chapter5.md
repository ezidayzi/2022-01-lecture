# 5 상속 Inheritance

* 상속의 장점
- 클래스 간결화 (멤버의 중복 작성 불필요)
- 클래스 관리 용

### 클래스 상속과 객체
- 부모 클래스 = 슈퍼 클래스
- 자식 클래스 = 서브 클래스
- extends 키워드 사용

```java
public class Person {
    //
}

public class Student extends Person {
    
}
```
### 서브 클래스/슈퍼클래스의 생성자 호출 및 실행
1) 서브 클래스 객체가 생성될 때 서브 클래스의 생성자와 슈퍼 클래스의 생성자가 모두 실행되는가?
   둘다 실행됨. 서브클래스의 객체가 생성되면 이 객체 속에 서브 클래스와 멤버와 슈퍼 클래스의 멤버가 모두 들어있다. 
   생성자의 목적은 객체 초기화에 있으므로 서브 클래스의 생성자는 생성된 객체 속에 들어있는 서브클래스의 멤버 초기화나 필요한 초기화를 수행하고,
    슈퍼 클래스의 생성자는 생성된 객체 속에 있는 슈퍼 클래스의 멤버 초기화나 필요한 초기화를 각각 수행
2) 서브 클래스의 생성자와 슈퍼 클래스의 생성자 중 누가 먼저 실행되는가?
   : 슈퍼클래스의 생성자가 먼저 실행된 후 서브 클래스의 생성자가 실행됨

### new에 의해 서브 클래스의 객체가 생성될 때
- 슈퍼 클래스 생성자와 서브 클래스 생성자 모두 실행됨
- 호출 순서: 서브 클래스의 생성자 먼저 호출, 서브 클래스의 생성자는 실행 전 슈퍼 클래스 생성자 호출
- 실행 순서: 슈퍼 클래스의 생성자가 실행된 후 서브 클래스의 생성자 실행
- 호출 순서와 실행 순서가 일치하지 않음을 주의하기

### 서브 클래스에서 슈퍼 클래스의 생성자 선택
- 상속 관계에서의 생성자
  - 슈퍼 클래스와 서브 클래스 각각 각각 여러 생성자 작성 가능
- 서브 클래스 생성자 작성 원칙
  - 서브 클래스 생성자에서 슈퍼 클래스 생성자 하나 선택
- 서브 클래스에서 슈퍼 클래스의 생성자를 선택하지 않는 경우
  - 컴파일러가 자동으로 슈퍼 클래스의 기본 생성자 선택
- 서브 클래스에서 슈퍼 클래스의 생성자를 선택하는 방법
  - super() 이용

### 업캐스팅
- 서브 클래스의 객체는
  - 슈퍼 클래스의 멤버를 모두 가지고 있음
  - 슈퍼 클래스의 객체로 취급할 수 있음
- 업 캐스팅이란?
  - 슈퍼타입 참조 변수는 서브 타입 객체를 가리킬 수 있다.
  - 서브 클래스 객체를 슈퍼 클래스 타입으로 타입 변환
  - **업캐스팅된 레퍼런스틑 객체 내에 슈퍼 클래스의 멤버만 접근가능**

### 다운 캐스팅
- 슈퍼 클래스 객체를 서브 클래스 타입으로 변환함
- 개발자의 명시적 타입이 필요함
  - 컴파일은 문제 없지만 런타임에 문제 생길 수도 있음

### instanceof 연산자와 객체의 타입 판단
- 업캐스팅된 레퍼런스로 객체의 타입 판단하기에는 어려움
  - 슈퍼 클래스는 여러 서브 클래스에 상속되기 때문임
- `instanceof` 연산자
  - 레퍼런스가 가리키는 객체의 타입 식별을 위해 사용됨

* 사용법
  객체 레퍼런스 instanceof 클래스타입 --> boolean
  연산의 결과: true, false

### 동적 바인딩
: 실행할 메소드를 실행시에 결정함
오버라이딩 메소드가 항상 호출

### 인터페이스
- 인터페이스는 추상메소드, 상수, public 가능
- 상위타입으로 가리킬때는 상위타입 만큼만 접근 가능함
- 인터페이스끼리 상속이 가능함
- 인터페이스를 구현하는 클래스는 인터페이스의 추상메소드를 언젠가는 구현해야한다.
